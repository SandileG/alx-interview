Pascal’s Triangle Project - README
Introduction
This project involves the implementation of Pascal’s Triangle using Python. Pascal's Triangle is a mathematical structure where each number is the sum of the two numbers directly above it in the previous row. In this project, you will be using several fundamental Python concepts to generate and manipulate Pascal’s Triangle.

Concepts to Know
1. Lists and List Comprehensions
Creation and Access: Understand how to create, access, modify, and iterate over lists.
List Comprehensions: Learn to use list comprehensions for concise and readable code. This will be especially helpful in generating rows of Pascal's Triangle efficiently.
2. Functions
Function Definition: Know how to define and call Python functions.
Parameter Passing: Learn how to pass parameters into functions and return results, specifically returning a list of lists that represent the rows of Pascal’s Triangle.
3. Loops
For and While Loops: Use loops to iterate through sequences. You’ll likely need nested loops to generate each row and calculate the elements of Pascal’s Triangle.
4. Conditional Statements
If, Elif, Else: Use conditional statements to implement logic, such as identifying the edges of Pascal’s Triangle where values are always 1.
5. Recursion (Optional)
Base and Recursive Cases: Though optional, recursion offers an alternative approach to generating Pascal’s Triangle by recognizing base cases (e.g., the first row) and recursive cases (subsequent rows).
6. Arithmetic Operations
Addition: Each element in Pascal’s Triangle is the sum of two elements from the previous row, so a clear understanding of basic arithmetic operations is key.
7. Indexing and Slicing
List Indexing: You’ll need to access specific elements from lists to calculate each element of Pascal’s Triangle.
List Slicing: Slicing can be useful when working with sublists or segments of rows in Pascal’s Triangle.
8. Memory Management
List Copying: Be mindful of how Python stores and copies lists. When constructing new rows based on previous rows, understand how references and copies affect memory.
9. Error and Exception Handling (Optional)
Handling Errors: Use try-except blocks to catch errors, such as invalid input types or out-of-bound errors while accessing lists.
10. Efficiency and Optimization
Time Complexity: Consider the time complexity of your solution, especially as the number of rows increases.
Space Complexity: Evaluate how much memory your solution consumes, particularly if you are generating and storing many rows.
